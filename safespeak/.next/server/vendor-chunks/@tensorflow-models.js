"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tensorflow-models";
exports.ids = ["vendor-chunks/@tensorflow-models"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tensorflow-models/blazeface/dist/blazeface.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow-models/blazeface/dist/blazeface.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlazeFaceModel: () => (/* binding */ BlazeFaceModel),\n/* harmony export */   load: () => (/* binding */ load)\n/* harmony export */ });\n/* harmony import */ var _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-converter */ \"(ssr)/./node_modules/@tensorflow/tfjs-converter/dist/index.js\");\n/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ \"(ssr)/./node_modules/@tensorflow/tfjs-core/dist/index.js\");\n/**\n * @license\n * Copyright 2023 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar disposeBox = function (box) {\n    box.startEndTensor.dispose();\n    box.startPoint.dispose();\n    box.endPoint.dispose();\n};\nvar createBox = function (startEndTensor) { return ({\n    startEndTensor: startEndTensor,\n    startPoint: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.slice(startEndTensor, [0, 0], [-1, 2]),\n    endPoint: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.slice(startEndTensor, [0, 2], [-1, 2])\n}); };\nvar scaleBox = function (box, factors) {\n    var starts = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.mul(box.startPoint, factors);\n    var ends = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.mul(box.endPoint, factors);\n    var newCoordinates = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.concat2d([starts, ends], 1);\n    return createBox(newCoordinates);\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ANCHORS_CONFIG = {\n    'strides': [8, 16],\n    'anchors': [2, 6]\n};\n// `NUM_LANDMARKS` is a fixed property of the model.\nvar NUM_LANDMARKS = 6;\nfunction generateAnchors(width, height, outputSpec) {\n    var anchors = [];\n    for (var i = 0; i < outputSpec.strides.length; i++) {\n        var stride = outputSpec.strides[i];\n        var gridRows = Math.floor((height + stride - 1) / stride);\n        var gridCols = Math.floor((width + stride - 1) / stride);\n        var anchorsNum = outputSpec.anchors[i];\n        for (var gridY = 0; gridY < gridRows; gridY++) {\n            var anchorY = stride * (gridY + 0.5);\n            for (var gridX = 0; gridX < gridCols; gridX++) {\n                var anchorX = stride * (gridX + 0.5);\n                for (var n = 0; n < anchorsNum; n++) {\n                    anchors.push([anchorX, anchorY]);\n                }\n            }\n        }\n    }\n    return anchors;\n}\nfunction decodeBounds(boxOutputs, anchors, inputSize) {\n    var boxStarts = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.slice(boxOutputs, [0, 1], [-1, 2]);\n    var centers = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.add(boxStarts, anchors);\n    var boxSizes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.slice(boxOutputs, [0, 3], [-1, 2]);\n    var boxSizesNormalized = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.div(boxSizes, inputSize);\n    var centersNormalized = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.div(centers, inputSize);\n    var halfBoxSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.div(boxSizesNormalized, 2);\n    var starts = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.sub(centersNormalized, halfBoxSize);\n    var ends = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.add(centersNormalized, halfBoxSize);\n    var startNormalized = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.mul(starts, inputSize);\n    var endNormalized = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.mul(ends, inputSize);\n    var concatAxis = 1;\n    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.concat2d([startNormalized, endNormalized], concatAxis);\n}\nfunction getInputTensorDimensions(input) {\n    return input instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.Tensor ? [input.shape[0], input.shape[1]] :\n        [input.height, input.width];\n}\nfunction flipFaceHorizontal(face, imageWidth) {\n    var flippedTopLeft, flippedBottomRight, flippedLandmarks;\n    if (face.topLeft instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.Tensor &&\n        face.bottomRight instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.Tensor) {\n        var _a = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n            return [\n                _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.concat([\n                    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.slice(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.sub(imageWidth - 1, face.topLeft), 0, 1),\n                    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.slice(face.topLeft, 1, 1)\n                ]),\n                _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.concat([\n                    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.sub(imageWidth - 1, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.slice(face.bottomRight, 0, 1)),\n                    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.slice(face.bottomRight, 1, 1)\n                ])\n            ];\n        }), topLeft = _a[0], bottomRight = _a[1];\n        flippedTopLeft = topLeft;\n        flippedBottomRight = bottomRight;\n        if (face.landmarks != null) {\n            flippedLandmarks = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n                var a = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.sub(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tensor1d([imageWidth - 1, 0]), face.landmarks);\n                var b = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tensor1d([1, -1]);\n                var product = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.mul(a, b);\n                return product;\n            });\n        }\n    }\n    else {\n        var _b = face.topLeft, topLeftX = _b[0], topLeftY = _b[1];\n        var _c = face.bottomRight, bottomRightX = _c[0], bottomRightY = _c[1];\n        flippedTopLeft = [imageWidth - 1 - topLeftX, topLeftY];\n        flippedBottomRight = [imageWidth - 1 - bottomRightX, bottomRightY];\n        if (face.landmarks != null) {\n            flippedLandmarks =\n                face.landmarks.map(function (coord) { return ([\n                    imageWidth - 1 - coord[0],\n                    coord[1]\n                ]); });\n        }\n    }\n    var flippedFace = {\n        topLeft: flippedTopLeft,\n        bottomRight: flippedBottomRight\n    };\n    if (flippedLandmarks != null) {\n        flippedFace.landmarks = flippedLandmarks;\n    }\n    if (face.probability != null) {\n        flippedFace.probability = face.probability instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.Tensor ?\n            face.probability.clone() :\n            face.probability;\n    }\n    return flippedFace;\n}\nfunction scaleBoxFromPrediction(face, scaleFactor) {\n    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n        var box;\n        if (face.hasOwnProperty('box')) {\n            box = face.box;\n        }\n        else {\n            box = face;\n        }\n        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.squeeze(scaleBox(box, scaleFactor).startEndTensor);\n    });\n}\nvar BlazeFaceModel = /** @class */ (function () {\n    function BlazeFaceModel(model, width, height, maxFaces, iouThreshold, scoreThreshold) {\n        this.blazeFaceModel = model;\n        this.width = width;\n        this.height = height;\n        this.maxFaces = maxFaces;\n        this.anchorsData = generateAnchors(width, height, ANCHORS_CONFIG);\n        this.anchors = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tensor2d(this.anchorsData);\n        this.inputSizeData = [width, height];\n        this.inputSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tensor1d([width, height]);\n        this.iouThreshold = iouThreshold;\n        this.scoreThreshold = scoreThreshold;\n    }\n    BlazeFaceModel.prototype.getBoundingBoxes = function (inputImage, returnTensors, annotateBoxes) {\n        if (annotateBoxes === void 0) { annotateBoxes = true; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, detectedOutputs, boxes, scores, savedConsoleWarnFn, boxIndicesTensor, boxIndices, boundingBoxes, originalHeight, originalWidth, scaleFactor, annotatedBoxes, _loop_1, i;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n                            var resizedImage = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.image.resizeBilinear(inputImage, [_this.width, _this.height]);\n                            var normalizedImage = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.mul(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.sub(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.div(resizedImage, 255), 0.5), 2);\n                            // [1, 897, 17] 1 = batch, 897 = number of anchors\n                            var batchedPrediction = _this.blazeFaceModel.predict(normalizedImage);\n                            var prediction = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.squeeze(batchedPrediction);\n                            var decodedBounds = decodeBounds(prediction, _this.anchors, _this.inputSize);\n                            var logits = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.slice(prediction, [0, 0], [-1, 1]);\n                            var scores = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.squeeze(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.sigmoid(logits));\n                            return [prediction, decodedBounds, scores];\n                        }), detectedOutputs = _a[0], boxes = _a[1], scores = _a[2];\n                        savedConsoleWarnFn = console.warn;\n                        console.warn = function () { };\n                        boxIndicesTensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.image.nonMaxSuppression(boxes, scores, this.maxFaces, this.iouThreshold, this.scoreThreshold);\n                        console.warn = savedConsoleWarnFn;\n                        return [4 /*yield*/, boxIndicesTensor.array()];\n                    case 1:\n                        boxIndices = _b.sent();\n                        boxIndicesTensor.dispose();\n                        boundingBoxes = boxIndices.map(function (boxIndex) { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.slice(boxes, [boxIndex, 0], [1, -1]); });\n                        if (!!returnTensors) return [3 /*break*/, 3];\n                        return [4 /*yield*/, Promise.all(boundingBoxes.map(function (boundingBox) { return __awaiter(_this, void 0, void 0, function () {\n                                var vals;\n                                return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0: return [4 /*yield*/, boundingBox.array()];\n                                        case 1:\n                                            vals = _a.sent();\n                                            boundingBox.dispose();\n                                            return [2 /*return*/, vals];\n                                    }\n                                });\n                            }); }))];\n                    case 2:\n                        boundingBoxes = _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        originalHeight = inputImage.shape[1];\n                        originalWidth = inputImage.shape[2];\n                        if (returnTensors) {\n                            scaleFactor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.div([originalWidth, originalHeight], this.inputSize);\n                        }\n                        else {\n                            scaleFactor = [\n                                originalWidth / this.inputSizeData[0],\n                                originalHeight / this.inputSizeData[1]\n                            ];\n                        }\n                        annotatedBoxes = [];\n                        _loop_1 = function (i) {\n                            var boundingBox = boundingBoxes[i];\n                            var annotatedBox = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n                                var box = boundingBox instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.Tensor ?\n                                    createBox(boundingBox) :\n                                    createBox(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tensor2d(boundingBox));\n                                if (!annotateBoxes) {\n                                    return box;\n                                }\n                                var boxIndex = boxIndices[i];\n                                var anchor;\n                                if (returnTensors) {\n                                    anchor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.slice(_this.anchors, [boxIndex, 0], [1, 2]);\n                                }\n                                else {\n                                    anchor = _this.anchorsData[boxIndex];\n                                }\n                                var landmarks = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.reshape(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.squeeze(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.slice(detectedOutputs, [boxIndex, NUM_LANDMARKS - 1], [1, -1])), [NUM_LANDMARKS, -1]);\n                                var probability = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.slice(scores, [boxIndex], [1]);\n                                return { box: box, landmarks: landmarks, probability: probability, anchor: anchor };\n                            });\n                            annotatedBoxes.push(annotatedBox);\n                        };\n                        for (i = 0; i < boundingBoxes.length; i++) {\n                            _loop_1(i);\n                        }\n                        boxes.dispose();\n                        scores.dispose();\n                        detectedOutputs.dispose();\n                        return [2 /*return*/, {\n                                boxes: annotatedBoxes,\n                                scaleFactor: scaleFactor\n                            }];\n                }\n            });\n        });\n    };\n    /**\n     * Returns an array of faces in an image.\n     *\n     * @param input The image to classify. Can be a tensor, DOM element image,\n     * video, or canvas.\n     * @param returnTensors (defaults to `false`) Whether to return tensors as\n     * opposed to values.\n     * @param flipHorizontal Whether to flip/mirror the facial keypoints\n     * horizontally. Should be true for videos that are flipped by default (e.g.\n     * webcams).\n     * @param annotateBoxes (defaults to `true`) Whether to annotate bounding\n     * boxes with additional properties such as landmarks and probability. Pass in\n     * `false` for faster inference if annotations are not needed.\n     *\n     * @return An array of detected faces, each with the following properties:\n     *  `topLeft`: the upper left coordinate of the face in the form `[x, y]`\n     *  `bottomRight`: the lower right coordinate of the face in the form `[x, y]`\n     *  `landmarks`: facial landmark coordinates\n     *  `probability`: the probability of the face being present\n     */\n    BlazeFaceModel.prototype.estimateFaces = function (input, returnTensors, flipHorizontal, annotateBoxes) {\n        if (returnTensors === void 0) { returnTensors = false; }\n        if (flipHorizontal === void 0) { flipHorizontal = false; }\n        if (annotateBoxes === void 0) { annotateBoxes = true; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, width, image, _b, boxes, scaleFactor;\n            var _this = this;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        _a = getInputTensorDimensions(input), width = _a[1];\n                        image = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n                            if (!(input instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.Tensor)) {\n                                input = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.browser.fromPixels(input);\n                            }\n                            return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.expandDims(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.cast(input, 'float32'), 0);\n                        });\n                        return [4 /*yield*/, this.getBoundingBoxes(image, returnTensors, annotateBoxes)];\n                    case 1:\n                        _b = _c.sent(), boxes = _b.boxes, scaleFactor = _b.scaleFactor;\n                        image.dispose();\n                        if (returnTensors) {\n                            return [2 /*return*/, boxes.map(function (face) {\n                                    var scaledBox = scaleBoxFromPrediction(face, scaleFactor);\n                                    var normalizedFace = {\n                                        topLeft: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.slice(scaledBox, [0], [2]),\n                                        bottomRight: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.slice(scaledBox, [2], [2])\n                                    };\n                                    if (annotateBoxes) {\n                                        var _a = face, landmarks = _a.landmarks, probability = _a.probability, anchor = _a.anchor;\n                                        var normalizedLandmarks = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.mul(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.add(landmarks, anchor), scaleFactor);\n                                        normalizedFace.landmarks = normalizedLandmarks;\n                                        normalizedFace.probability = probability;\n                                    }\n                                    if (flipHorizontal) {\n                                        normalizedFace = flipFaceHorizontal(normalizedFace, width);\n                                    }\n                                    return normalizedFace;\n                                })];\n                        }\n                        return [2 /*return*/, Promise.all(boxes.map(function (face) { return __awaiter(_this, void 0, void 0, function () {\n                                var scaledBox, normalizedFace, boxData, _a, landmarkData, boxData, probabilityData, anchor_1, _b, scaleFactorX_1, scaleFactorY_1, scaledLandmarks;\n                                var _this = this;\n                                return __generator(this, function (_c) {\n                                    switch (_c.label) {\n                                        case 0:\n                                            scaledBox = scaleBoxFromPrediction(face, scaleFactor);\n                                            if (!!annotateBoxes) return [3 /*break*/, 2];\n                                            return [4 /*yield*/, scaledBox.array()];\n                                        case 1:\n                                            boxData = _c.sent();\n                                            normalizedFace = {\n                                                topLeft: boxData.slice(0, 2),\n                                                bottomRight: boxData.slice(2)\n                                            };\n                                            return [3 /*break*/, 4];\n                                        case 2: return [4 /*yield*/, Promise.all([face.landmarks, scaledBox, face.probability].map(function (d) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {\n                                                return [2 /*return*/, d.array()];\n                                            }); }); }))];\n                                        case 3:\n                                            _a = _c.sent(), landmarkData = _a[0], boxData = _a[1], probabilityData = _a[2];\n                                            anchor_1 = face.anchor;\n                                            _b = scaleFactor, scaleFactorX_1 = _b[0], scaleFactorY_1 = _b[1];\n                                            scaledLandmarks = landmarkData\n                                                .map(function (landmark) { return ([\n                                                (landmark[0] + anchor_1[0]) * scaleFactorX_1,\n                                                (landmark[1] + anchor_1[1]) * scaleFactorY_1\n                                            ]); });\n                                            normalizedFace = {\n                                                topLeft: boxData.slice(0, 2),\n                                                bottomRight: boxData.slice(2),\n                                                landmarks: scaledLandmarks,\n                                                probability: probabilityData\n                                            };\n                                            disposeBox(face.box);\n                                            face.landmarks.dispose();\n                                            face.probability.dispose();\n                                            _c.label = 4;\n                                        case 4:\n                                            scaledBox.dispose();\n                                            if (flipHorizontal) {\n                                                normalizedFace = flipFaceHorizontal(normalizedFace, width);\n                                            }\n                                            return [2 /*return*/, normalizedFace];\n                                    }\n                                });\n                            }); }))];\n                }\n            });\n        });\n    };\n    /**\n     * Dispose the WebGL memory held by the underlying model.\n     */\n    BlazeFaceModel.prototype.dispose = function () {\n        this.blazeFaceModel.dispose();\n        this.anchors.dispose();\n        this.inputSize.dispose();\n    };\n    return BlazeFaceModel;\n}());\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar BLAZEFACE_MODEL_URL = 'https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1';\n/**\n * Load blazeface.\n *\n * @param config A configuration object with the following properties:\n *  `maxFaces` The maximum number of faces returned by the model.\n *  `inputWidth` The width of the input image.\n *  `inputHeight` The height of the input image.\n *  `iouThreshold` The threshold for deciding whether boxes overlap too\n * much.\n *  `scoreThreshold` The threshold for deciding when to remove boxes based\n * on score.\n */\nfunction load(_a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.maxFaces, maxFaces = _c === void 0 ? 10 : _c, _d = _b.inputWidth, inputWidth = _d === void 0 ? 128 : _d, _e = _b.inputHeight, inputHeight = _e === void 0 ? 128 : _e, _f = _b.iouThreshold, iouThreshold = _f === void 0 ? 0.3 : _f, _g = _b.scoreThreshold, scoreThreshold = _g === void 0 ? 0.75 : _g, modelUrl = _b.modelUrl;\n    return __awaiter(this, void 0, void 0, function () {\n        var blazeface, model;\n        return __generator(this, function (_h) {\n            switch (_h.label) {\n                case 0:\n                    if (!(modelUrl != null)) return [3 /*break*/, 2];\n                    return [4 /*yield*/, _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_0__.loadGraphModel(modelUrl)];\n                case 1:\n                    blazeface = _h.sent();\n                    return [3 /*break*/, 4];\n                case 2: return [4 /*yield*/, _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_0__.loadGraphModel(BLAZEFACE_MODEL_URL, {\n                        fromTFHub: true,\n                    })];\n                case 3:\n                    blazeface = _h.sent();\n                    _h.label = 4;\n                case 4:\n                    model = new BlazeFaceModel(blazeface, inputWidth, inputHeight, maxFaces, iouThreshold, scoreThreshold);\n                    return [2 /*return*/, model];\n            }\n        });\n    });\n}\n\n\n//# sourceMappingURL=blazeface.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3ctbW9kZWxzL2JsYXplZmFjZS9kaXN0L2JsYXplZmFjZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxRDtBQUNUOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0osc0RBQXNEO0FBQ3hNO0FBQ0EsNkNBQTZDLElBQUksSUFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw2QkFBNkIsSUFBSTtBQUNqQztBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0VBQXFCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxzRUFBcUI7QUFDbEU7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVnQztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NhZmVzcGVhay8uL25vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy1tb2RlbHMvYmxhemVmYWNlL2Rpc3QvYmxhemVmYWNlLmVzbS5qcz80MzdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0ICogYXMgdGZjb252IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyJztcbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGRpc3Bvc2VCb3ggPSBmdW5jdGlvbiAoYm94KSB7XG4gICAgYm94LnN0YXJ0RW5kVGVuc29yLmRpc3Bvc2UoKTtcbiAgICBib3guc3RhcnRQb2ludC5kaXNwb3NlKCk7XG4gICAgYm94LmVuZFBvaW50LmRpc3Bvc2UoKTtcbn07XG52YXIgY3JlYXRlQm94ID0gZnVuY3Rpb24gKHN0YXJ0RW5kVGVuc29yKSB7IHJldHVybiAoe1xuICAgIHN0YXJ0RW5kVGVuc29yOiBzdGFydEVuZFRlbnNvcixcbiAgICBzdGFydFBvaW50OiB0Zi5zbGljZShzdGFydEVuZFRlbnNvciwgWzAsIDBdLCBbLTEsIDJdKSxcbiAgICBlbmRQb2ludDogdGYuc2xpY2Uoc3RhcnRFbmRUZW5zb3IsIFswLCAyXSwgWy0xLCAyXSlcbn0pOyB9O1xudmFyIHNjYWxlQm94ID0gZnVuY3Rpb24gKGJveCwgZmFjdG9ycykge1xuICAgIHZhciBzdGFydHMgPSB0Zi5tdWwoYm94LnN0YXJ0UG9pbnQsIGZhY3RvcnMpO1xuICAgIHZhciBlbmRzID0gdGYubXVsKGJveC5lbmRQb2ludCwgZmFjdG9ycyk7XG4gICAgdmFyIG5ld0Nvb3JkaW5hdGVzID0gdGYuY29uY2F0MmQoW3N0YXJ0cywgZW5kc10sIDEpO1xuICAgIHJldHVybiBjcmVhdGVCb3gobmV3Q29vcmRpbmF0ZXMpO1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBBTkNIT1JTX0NPTkZJRyA9IHtcbiAgICAnc3RyaWRlcyc6IFs4LCAxNl0sXG4gICAgJ2FuY2hvcnMnOiBbMiwgNl1cbn07XG4vLyBgTlVNX0xBTkRNQVJLU2AgaXMgYSBmaXhlZCBwcm9wZXJ0eSBvZiB0aGUgbW9kZWwuXG52YXIgTlVNX0xBTkRNQVJLUyA9IDY7XG5mdW5jdGlvbiBnZW5lcmF0ZUFuY2hvcnMod2lkdGgsIGhlaWdodCwgb3V0cHV0U3BlYykge1xuICAgIHZhciBhbmNob3JzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXRTcGVjLnN0cmlkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN0cmlkZSA9IG91dHB1dFNwZWMuc3RyaWRlc1tpXTtcbiAgICAgICAgdmFyIGdyaWRSb3dzID0gTWF0aC5mbG9vcigoaGVpZ2h0ICsgc3RyaWRlIC0gMSkgLyBzdHJpZGUpO1xuICAgICAgICB2YXIgZ3JpZENvbHMgPSBNYXRoLmZsb29yKCh3aWR0aCArIHN0cmlkZSAtIDEpIC8gc3RyaWRlKTtcbiAgICAgICAgdmFyIGFuY2hvcnNOdW0gPSBvdXRwdXRTcGVjLmFuY2hvcnNbaV07XG4gICAgICAgIGZvciAodmFyIGdyaWRZID0gMDsgZ3JpZFkgPCBncmlkUm93czsgZ3JpZFkrKykge1xuICAgICAgICAgICAgdmFyIGFuY2hvclkgPSBzdHJpZGUgKiAoZ3JpZFkgKyAwLjUpO1xuICAgICAgICAgICAgZm9yICh2YXIgZ3JpZFggPSAwOyBncmlkWCA8IGdyaWRDb2xzOyBncmlkWCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuY2hvclggPSBzdHJpZGUgKiAoZ3JpZFggKyAwLjUpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgYW5jaG9yc051bTsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcnMucHVzaChbYW5jaG9yWCwgYW5jaG9yWV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW5jaG9ycztcbn1cbmZ1bmN0aW9uIGRlY29kZUJvdW5kcyhib3hPdXRwdXRzLCBhbmNob3JzLCBpbnB1dFNpemUpIHtcbiAgICB2YXIgYm94U3RhcnRzID0gdGYuc2xpY2UoYm94T3V0cHV0cywgWzAsIDFdLCBbLTEsIDJdKTtcbiAgICB2YXIgY2VudGVycyA9IHRmLmFkZChib3hTdGFydHMsIGFuY2hvcnMpO1xuICAgIHZhciBib3hTaXplcyA9IHRmLnNsaWNlKGJveE91dHB1dHMsIFswLCAzXSwgWy0xLCAyXSk7XG4gICAgdmFyIGJveFNpemVzTm9ybWFsaXplZCA9IHRmLmRpdihib3hTaXplcywgaW5wdXRTaXplKTtcbiAgICB2YXIgY2VudGVyc05vcm1hbGl6ZWQgPSB0Zi5kaXYoY2VudGVycywgaW5wdXRTaXplKTtcbiAgICB2YXIgaGFsZkJveFNpemUgPSB0Zi5kaXYoYm94U2l6ZXNOb3JtYWxpemVkLCAyKTtcbiAgICB2YXIgc3RhcnRzID0gdGYuc3ViKGNlbnRlcnNOb3JtYWxpemVkLCBoYWxmQm94U2l6ZSk7XG4gICAgdmFyIGVuZHMgPSB0Zi5hZGQoY2VudGVyc05vcm1hbGl6ZWQsIGhhbGZCb3hTaXplKTtcbiAgICB2YXIgc3RhcnROb3JtYWxpemVkID0gdGYubXVsKHN0YXJ0cywgaW5wdXRTaXplKTtcbiAgICB2YXIgZW5kTm9ybWFsaXplZCA9IHRmLm11bChlbmRzLCBpbnB1dFNpemUpO1xuICAgIHZhciBjb25jYXRBeGlzID0gMTtcbiAgICByZXR1cm4gdGYuY29uY2F0MmQoW3N0YXJ0Tm9ybWFsaXplZCwgZW5kTm9ybWFsaXplZF0sIGNvbmNhdEF4aXMpO1xufVxuZnVuY3Rpb24gZ2V0SW5wdXRUZW5zb3JEaW1lbnNpb25zKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgdGYuVGVuc29yID8gW2lucHV0LnNoYXBlWzBdLCBpbnB1dC5zaGFwZVsxXV0gOlxuICAgICAgICBbaW5wdXQuaGVpZ2h0LCBpbnB1dC53aWR0aF07XG59XG5mdW5jdGlvbiBmbGlwRmFjZUhvcml6b250YWwoZmFjZSwgaW1hZ2VXaWR0aCkge1xuICAgIHZhciBmbGlwcGVkVG9wTGVmdCwgZmxpcHBlZEJvdHRvbVJpZ2h0LCBmbGlwcGVkTGFuZG1hcmtzO1xuICAgIGlmIChmYWNlLnRvcExlZnQgaW5zdGFuY2VvZiB0Zi5UZW5zb3IgJiZcbiAgICAgICAgZmFjZS5ib3R0b21SaWdodCBpbnN0YW5jZW9mIHRmLlRlbnNvcikge1xuICAgICAgICB2YXIgX2EgPSB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGYuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgdGYuc2xpY2UodGYuc3ViKGltYWdlV2lkdGggLSAxLCBmYWNlLnRvcExlZnQpLCAwLCAxKSxcbiAgICAgICAgICAgICAgICAgICAgdGYuc2xpY2UoZmFjZS50b3BMZWZ0LCAxLCAxKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIHRmLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgIHRmLnN1YihpbWFnZVdpZHRoIC0gMSwgdGYuc2xpY2UoZmFjZS5ib3R0b21SaWdodCwgMCwgMSkpLFxuICAgICAgICAgICAgICAgICAgICB0Zi5zbGljZShmYWNlLmJvdHRvbVJpZ2h0LCAxLCAxKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KSwgdG9wTGVmdCA9IF9hWzBdLCBib3R0b21SaWdodCA9IF9hWzFdO1xuICAgICAgICBmbGlwcGVkVG9wTGVmdCA9IHRvcExlZnQ7XG4gICAgICAgIGZsaXBwZWRCb3R0b21SaWdodCA9IGJvdHRvbVJpZ2h0O1xuICAgICAgICBpZiAoZmFjZS5sYW5kbWFya3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZmxpcHBlZExhbmRtYXJrcyA9IHRmLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gdGYuc3ViKHRmLnRlbnNvcjFkKFtpbWFnZVdpZHRoIC0gMSwgMF0pLCBmYWNlLmxhbmRtYXJrcyk7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSB0Zi50ZW5zb3IxZChbMSwgLTFdKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvZHVjdCA9IHRmLm11bChhLCBiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvZHVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgX2IgPSBmYWNlLnRvcExlZnQsIHRvcExlZnRYID0gX2JbMF0sIHRvcExlZnRZID0gX2JbMV07XG4gICAgICAgIHZhciBfYyA9IGZhY2UuYm90dG9tUmlnaHQsIGJvdHRvbVJpZ2h0WCA9IF9jWzBdLCBib3R0b21SaWdodFkgPSBfY1sxXTtcbiAgICAgICAgZmxpcHBlZFRvcExlZnQgPSBbaW1hZ2VXaWR0aCAtIDEgLSB0b3BMZWZ0WCwgdG9wTGVmdFldO1xuICAgICAgICBmbGlwcGVkQm90dG9tUmlnaHQgPSBbaW1hZ2VXaWR0aCAtIDEgLSBib3R0b21SaWdodFgsIGJvdHRvbVJpZ2h0WV07XG4gICAgICAgIGlmIChmYWNlLmxhbmRtYXJrcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmbGlwcGVkTGFuZG1hcmtzID1cbiAgICAgICAgICAgICAgICBmYWNlLmxhbmRtYXJrcy5tYXAoZnVuY3Rpb24gKGNvb3JkKSB7IHJldHVybiAoW1xuICAgICAgICAgICAgICAgICAgICBpbWFnZVdpZHRoIC0gMSAtIGNvb3JkWzBdLFxuICAgICAgICAgICAgICAgICAgICBjb29yZFsxXVxuICAgICAgICAgICAgICAgIF0pOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZmxpcHBlZEZhY2UgPSB7XG4gICAgICAgIHRvcExlZnQ6IGZsaXBwZWRUb3BMZWZ0LFxuICAgICAgICBib3R0b21SaWdodDogZmxpcHBlZEJvdHRvbVJpZ2h0XG4gICAgfTtcbiAgICBpZiAoZmxpcHBlZExhbmRtYXJrcyAhPSBudWxsKSB7XG4gICAgICAgIGZsaXBwZWRGYWNlLmxhbmRtYXJrcyA9IGZsaXBwZWRMYW5kbWFya3M7XG4gICAgfVxuICAgIGlmIChmYWNlLnByb2JhYmlsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgZmxpcHBlZEZhY2UucHJvYmFiaWxpdHkgPSBmYWNlLnByb2JhYmlsaXR5IGluc3RhbmNlb2YgdGYuVGVuc29yID9cbiAgICAgICAgICAgIGZhY2UucHJvYmFiaWxpdHkuY2xvbmUoKSA6XG4gICAgICAgICAgICBmYWNlLnByb2JhYmlsaXR5O1xuICAgIH1cbiAgICByZXR1cm4gZmxpcHBlZEZhY2U7XG59XG5mdW5jdGlvbiBzY2FsZUJveEZyb21QcmVkaWN0aW9uKGZhY2UsIHNjYWxlRmFjdG9yKSB7XG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm94O1xuICAgICAgICBpZiAoZmFjZS5oYXNPd25Qcm9wZXJ0eSgnYm94JykpIHtcbiAgICAgICAgICAgIGJveCA9IGZhY2UuYm94O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm94ID0gZmFjZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGYuc3F1ZWV6ZShzY2FsZUJveChib3gsIHNjYWxlRmFjdG9yKS5zdGFydEVuZFRlbnNvcik7XG4gICAgfSk7XG59XG52YXIgQmxhemVGYWNlTW9kZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmxhemVGYWNlTW9kZWwobW9kZWwsIHdpZHRoLCBoZWlnaHQsIG1heEZhY2VzLCBpb3VUaHJlc2hvbGQsIHNjb3JlVGhyZXNob2xkKSB7XG4gICAgICAgIHRoaXMuYmxhemVGYWNlTW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5tYXhGYWNlcyA9IG1heEZhY2VzO1xuICAgICAgICB0aGlzLmFuY2hvcnNEYXRhID0gZ2VuZXJhdGVBbmNob3JzKHdpZHRoLCBoZWlnaHQsIEFOQ0hPUlNfQ09ORklHKTtcbiAgICAgICAgdGhpcy5hbmNob3JzID0gdGYudGVuc29yMmQodGhpcy5hbmNob3JzRGF0YSk7XG4gICAgICAgIHRoaXMuaW5wdXRTaXplRGF0YSA9IFt3aWR0aCwgaGVpZ2h0XTtcbiAgICAgICAgdGhpcy5pbnB1dFNpemUgPSB0Zi50ZW5zb3IxZChbd2lkdGgsIGhlaWdodF0pO1xuICAgICAgICB0aGlzLmlvdVRocmVzaG9sZCA9IGlvdVRocmVzaG9sZDtcbiAgICAgICAgdGhpcy5zY29yZVRocmVzaG9sZCA9IHNjb3JlVGhyZXNob2xkO1xuICAgIH1cbiAgICBCbGF6ZUZhY2VNb2RlbC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3hlcyA9IGZ1bmN0aW9uIChpbnB1dEltYWdlLCByZXR1cm5UZW5zb3JzLCBhbm5vdGF0ZUJveGVzKSB7XG4gICAgICAgIGlmIChhbm5vdGF0ZUJveGVzID09PSB2b2lkIDApIHsgYW5ub3RhdGVCb3hlcyA9IHRydWU7IH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBkZXRlY3RlZE91dHB1dHMsIGJveGVzLCBzY29yZXMsIHNhdmVkQ29uc29sZVdhcm5GbiwgYm94SW5kaWNlc1RlbnNvciwgYm94SW5kaWNlcywgYm91bmRpbmdCb3hlcywgb3JpZ2luYWxIZWlnaHQsIG9yaWdpbmFsV2lkdGgsIHNjYWxlRmFjdG9yLCBhbm5vdGF0ZWRCb3hlcywgX2xvb3BfMSwgaTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRmLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNpemVkSW1hZ2UgPSB0Zi5pbWFnZS5yZXNpemVCaWxpbmVhcihpbnB1dEltYWdlLCBbX3RoaXMud2lkdGgsIF90aGlzLmhlaWdodF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkSW1hZ2UgPSB0Zi5tdWwodGYuc3ViKHRmLmRpdihyZXNpemVkSW1hZ2UsIDI1NSksIDAuNSksIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFsxLCA4OTcsIDE3XSAxID0gYmF0Y2gsIDg5NyA9IG51bWJlciBvZiBhbmNob3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhdGNoZWRQcmVkaWN0aW9uID0gX3RoaXMuYmxhemVGYWNlTW9kZWwucHJlZGljdChub3JtYWxpemVkSW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmVkaWN0aW9uID0gdGYuc3F1ZWV6ZShiYXRjaGVkUHJlZGljdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY29kZWRCb3VuZHMgPSBkZWNvZGVCb3VuZHMocHJlZGljdGlvbiwgX3RoaXMuYW5jaG9ycywgX3RoaXMuaW5wdXRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9naXRzID0gdGYuc2xpY2UocHJlZGljdGlvbiwgWzAsIDBdLCBbLTEsIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NvcmVzID0gdGYuc3F1ZWV6ZSh0Zi5zaWdtb2lkKGxvZ2l0cykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbcHJlZGljdGlvbiwgZGVjb2RlZEJvdW5kcywgc2NvcmVzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBkZXRlY3RlZE91dHB1dHMgPSBfYVswXSwgYm94ZXMgPSBfYVsxXSwgc2NvcmVzID0gX2FbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlZENvbnNvbGVXYXJuRm4gPSBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4gPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICBib3hJbmRpY2VzVGVuc29yID0gdGYuaW1hZ2Uubm9uTWF4U3VwcHJlc3Npb24oYm94ZXMsIHNjb3JlcywgdGhpcy5tYXhGYWNlcywgdGhpcy5pb3VUaHJlc2hvbGQsIHRoaXMuc2NvcmVUaHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuID0gc2F2ZWRDb25zb2xlV2FybkZuO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYm94SW5kaWNlc1RlbnNvci5hcnJheSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYm94SW5kaWNlcyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveEluZGljZXNUZW5zb3IuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRpbmdCb3hlcyA9IGJveEluZGljZXMubWFwKGZ1bmN0aW9uIChib3hJbmRleCkgeyByZXR1cm4gdGYuc2xpY2UoYm94ZXMsIFtib3hJbmRleCwgMF0sIFsxLCAtMV0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIXJldHVyblRlbnNvcnMpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwoYm91bmRpbmdCb3hlcy5tYXAoZnVuY3Rpb24gKGJvdW5kaW5nQm94KSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBib3VuZGluZ0JveC5hcnJheSgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nQm94LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZhbHNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSkpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRpbmdCb3hlcyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxIZWlnaHQgPSBpbnB1dEltYWdlLnNoYXBlWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxXaWR0aCA9IGlucHV0SW1hZ2Uuc2hhcGVbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVGVuc29ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlRmFjdG9yID0gdGYuZGl2KFtvcmlnaW5hbFdpZHRoLCBvcmlnaW5hbEhlaWdodF0sIHRoaXMuaW5wdXRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlRmFjdG9yID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFdpZHRoIC8gdGhpcy5pbnB1dFNpemVEYXRhWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEhlaWdodCAvIHRoaXMuaW5wdXRTaXplRGF0YVsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZWRCb3hlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3hlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGVkQm94ID0gdGYudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3ggPSBib3VuZGluZ0JveCBpbnN0YW5jZW9mIHRmLlRlbnNvciA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVCb3goYm91bmRpbmdCb3gpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUJveCh0Zi50ZW5zb3IyZChib3VuZGluZ0JveCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFubm90YXRlQm94ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBib3g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJveEluZGV4ID0gYm94SW5kaWNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblRlbnNvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IHRmLnNsaWNlKF90aGlzLmFuY2hvcnMsIFtib3hJbmRleCwgMF0sIFsxLCAyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSBfdGhpcy5hbmNob3JzRGF0YVtib3hJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmRtYXJrcyA9IHRmLnJlc2hhcGUodGYuc3F1ZWV6ZSh0Zi5zbGljZShkZXRlY3RlZE91dHB1dHMsIFtib3hJbmRleCwgTlVNX0xBTkRNQVJLUyAtIDFdLCBbMSwgLTFdKSksIFtOVU1fTEFORE1BUktTLCAtMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvYmFiaWxpdHkgPSB0Zi5zbGljZShzY29yZXMsIFtib3hJbmRleF0sIFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGJveDogYm94LCBsYW5kbWFya3M6IGxhbmRtYXJrcywgcHJvYmFiaWxpdHk6IHByb2JhYmlsaXR5LCBhbmNob3I6IGFuY2hvciB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRlZEJveGVzLnB1c2goYW5ub3RhdGVkQm94KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm91bmRpbmdCb3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBib3hlcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29yZXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWRPdXRwdXRzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveGVzOiBhbm5vdGF0ZWRCb3hlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVGYWN0b3I6IHNjYWxlRmFjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBmYWNlcyBpbiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW1hZ2UgdG8gY2xhc3NpZnkuIENhbiBiZSBhIHRlbnNvciwgRE9NIGVsZW1lbnQgaW1hZ2UsXG4gICAgICogdmlkZW8sIG9yIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0gcmV0dXJuVGVuc29ycyAoZGVmYXVsdHMgdG8gYGZhbHNlYCkgV2hldGhlciB0byByZXR1cm4gdGVuc29ycyBhc1xuICAgICAqIG9wcG9zZWQgdG8gdmFsdWVzLlxuICAgICAqIEBwYXJhbSBmbGlwSG9yaXpvbnRhbCBXaGV0aGVyIHRvIGZsaXAvbWlycm9yIHRoZSBmYWNpYWwga2V5cG9pbnRzXG4gICAgICogaG9yaXpvbnRhbGx5LiBTaG91bGQgYmUgdHJ1ZSBmb3IgdmlkZW9zIHRoYXQgYXJlIGZsaXBwZWQgYnkgZGVmYXVsdCAoZS5nLlxuICAgICAqIHdlYmNhbXMpLlxuICAgICAqIEBwYXJhbSBhbm5vdGF0ZUJveGVzIChkZWZhdWx0cyB0byBgdHJ1ZWApIFdoZXRoZXIgdG8gYW5ub3RhdGUgYm91bmRpbmdcbiAgICAgKiBib3hlcyB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllcyBzdWNoIGFzIGxhbmRtYXJrcyBhbmQgcHJvYmFiaWxpdHkuIFBhc3MgaW5cbiAgICAgKiBgZmFsc2VgIGZvciBmYXN0ZXIgaW5mZXJlbmNlIGlmIGFubm90YXRpb25zIGFyZSBub3QgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHJldHVybiBBbiBhcnJheSBvZiBkZXRlY3RlZCBmYWNlcywgZWFjaCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiAgYHRvcExlZnRgOiB0aGUgdXBwZXIgbGVmdCBjb29yZGluYXRlIG9mIHRoZSBmYWNlIGluIHRoZSBmb3JtIGBbeCwgeV1gXG4gICAgICogIGBib3R0b21SaWdodGA6IHRoZSBsb3dlciByaWdodCBjb29yZGluYXRlIG9mIHRoZSBmYWNlIGluIHRoZSBmb3JtIGBbeCwgeV1gXG4gICAgICogIGBsYW5kbWFya3NgOiBmYWNpYWwgbGFuZG1hcmsgY29vcmRpbmF0ZXNcbiAgICAgKiAgYHByb2JhYmlsaXR5YDogdGhlIHByb2JhYmlsaXR5IG9mIHRoZSBmYWNlIGJlaW5nIHByZXNlbnRcbiAgICAgKi9cbiAgICBCbGF6ZUZhY2VNb2RlbC5wcm90b3R5cGUuZXN0aW1hdGVGYWNlcyA9IGZ1bmN0aW9uIChpbnB1dCwgcmV0dXJuVGVuc29ycywgZmxpcEhvcml6b250YWwsIGFubm90YXRlQm94ZXMpIHtcbiAgICAgICAgaWYgKHJldHVyblRlbnNvcnMgPT09IHZvaWQgMCkgeyByZXR1cm5UZW5zb3JzID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGZsaXBIb3Jpem9udGFsID09PSB2b2lkIDApIHsgZmxpcEhvcml6b250YWwgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoYW5ub3RhdGVCb3hlcyA9PT0gdm9pZCAwKSB7IGFubm90YXRlQm94ZXMgPSB0cnVlOyB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgd2lkdGgsIGltYWdlLCBfYiwgYm94ZXMsIHNjYWxlRmFjdG9yO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gZ2V0SW5wdXRUZW5zb3JEaW1lbnNpb25zKGlucHV0KSwgd2lkdGggPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlID0gdGYudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiB0Zi5UZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0ID0gdGYuYnJvd3Nlci5mcm9tUGl4ZWxzKGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRmLmV4cGFuZERpbXModGYuY2FzdChpbnB1dCwgJ2Zsb2F0MzInKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0Qm91bmRpbmdCb3hlcyhpbWFnZSwgcmV0dXJuVGVuc29ycywgYW5ub3RhdGVCb3hlcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IF9jLnNlbnQoKSwgYm94ZXMgPSBfYi5ib3hlcywgc2NhbGVGYWN0b3IgPSBfYi5zY2FsZUZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5UZW5zb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJveGVzLm1hcChmdW5jdGlvbiAoZmFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlZEJveCA9IHNjYWxlQm94RnJvbVByZWRpY3Rpb24oZmFjZSwgc2NhbGVGYWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRGYWNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcExlZnQ6IHRmLnNsaWNlKHNjYWxlZEJveCwgWzBdLCBbMl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0OiB0Zi5zbGljZShzY2FsZWRCb3gsIFsyXSwgWzJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0ZUJveGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gZmFjZSwgbGFuZG1hcmtzID0gX2EubGFuZG1hcmtzLCBwcm9iYWJpbGl0eSA9IF9hLnByb2JhYmlsaXR5LCBhbmNob3IgPSBfYS5hbmNob3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRMYW5kbWFya3MgPSB0Zi5tdWwodGYuYWRkKGxhbmRtYXJrcywgYW5jaG9yKSwgc2NhbGVGYWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRGYWNlLmxhbmRtYXJrcyA9IG5vcm1hbGl6ZWRMYW5kbWFya3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEZhY2UucHJvYmFiaWxpdHkgPSBwcm9iYWJpbGl0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbGlwSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRGYWNlID0gZmxpcEZhY2VIb3Jpem9udGFsKG5vcm1hbGl6ZWRGYWNlLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZEZhY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBQcm9taXNlLmFsbChib3hlcy5tYXAoZnVuY3Rpb24gKGZhY2UpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlZEJveCwgbm9ybWFsaXplZEZhY2UsIGJveERhdGEsIF9hLCBsYW5kbWFya0RhdGEsIGJveERhdGEsIHByb2JhYmlsaXR5RGF0YSwgYW5jaG9yXzEsIF9iLCBzY2FsZUZhY3RvclhfMSwgc2NhbGVGYWN0b3JZXzEsIHNjYWxlZExhbmRtYXJrcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkQm94ID0gc2NhbGVCb3hGcm9tUHJlZGljdGlvbihmYWNlLCBzY2FsZUZhY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIWFubm90YXRlQm94ZXMpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzY2FsZWRCb3guYXJyYXkoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3hEYXRhID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkRmFjZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcExlZnQ6IGJveERhdGEuc2xpY2UoMCwgMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b21SaWdodDogYm94RGF0YS5zbGljZSgyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKFtmYWNlLmxhbmRtYXJrcywgc2NhbGVkQm94LCBmYWNlLnByb2JhYmlsaXR5XS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGQuYXJyYXkoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KTsgfSkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gX2Muc2VudCgpLCBsYW5kbWFya0RhdGEgPSBfYVswXSwgYm94RGF0YSA9IF9hWzFdLCBwcm9iYWJpbGl0eURhdGEgPSBfYVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yXzEgPSBmYWNlLmFuY2hvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSBzY2FsZUZhY3Rvciwgc2NhbGVGYWN0b3JYXzEgPSBfYlswXSwgc2NhbGVGYWN0b3JZXzEgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkTGFuZG1hcmtzID0gbGFuZG1hcmtEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChsYW5kbWFyaykgeyByZXR1cm4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsYW5kbWFya1swXSArIGFuY2hvcl8xWzBdKSAqIHNjYWxlRmFjdG9yWF8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxhbmRtYXJrWzFdICsgYW5jaG9yXzFbMV0pICogc2NhbGVGYWN0b3JZXzFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkRmFjZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcExlZnQ6IGJveERhdGEuc2xpY2UoMCwgMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b21SaWdodDogYm94RGF0YS5zbGljZSgyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmRtYXJrczogc2NhbGVkTGFuZG1hcmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvYmFiaWxpdHk6IHByb2JhYmlsaXR5RGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwb3NlQm94KGZhY2UuYm94KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjZS5sYW5kbWFya3MuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNlLnByb2JhYmlsaXR5LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkQm94LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZsaXBIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkRmFjZSA9IGZsaXBGYWNlSG9yaXpvbnRhbChub3JtYWxpemVkRmFjZSwgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBub3JtYWxpemVkRmFjZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc3Bvc2UgdGhlIFdlYkdMIG1lbW9yeSBoZWxkIGJ5IHRoZSB1bmRlcmx5aW5nIG1vZGVsLlxuICAgICAqL1xuICAgIEJsYXplRmFjZU1vZGVsLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmJsYXplRmFjZU1vZGVsLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5hbmNob3JzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5pbnB1dFNpemUuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIEJsYXplRmFjZU1vZGVsO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBCTEFaRUZBQ0VfTU9ERUxfVVJMID0gJ2h0dHBzOi8vdGZodWIuZGV2L3RlbnNvcmZsb3cvdGZqcy1tb2RlbC9ibGF6ZWZhY2UvMS9kZWZhdWx0LzEnO1xuLyoqXG4gKiBMb2FkIGJsYXplZmFjZS5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIEEgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiAgYG1heEZhY2VzYCBUaGUgbWF4aW11bSBudW1iZXIgb2YgZmFjZXMgcmV0dXJuZWQgYnkgdGhlIG1vZGVsLlxuICogIGBpbnB1dFdpZHRoYCBUaGUgd2lkdGggb2YgdGhlIGlucHV0IGltYWdlLlxuICogIGBpbnB1dEhlaWdodGAgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgaW1hZ2UuXG4gKiAgYGlvdVRocmVzaG9sZGAgVGhlIHRocmVzaG9sZCBmb3IgZGVjaWRpbmcgd2hldGhlciBib3hlcyBvdmVybGFwIHRvb1xuICogbXVjaC5cbiAqICBgc2NvcmVUaHJlc2hvbGRgIFRoZSB0aHJlc2hvbGQgZm9yIGRlY2lkaW5nIHdoZW4gdG8gcmVtb3ZlIGJveGVzIGJhc2VkXG4gKiBvbiBzY29yZS5cbiAqL1xuZnVuY3Rpb24gbG9hZChfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLm1heEZhY2VzLCBtYXhGYWNlcyA9IF9jID09PSB2b2lkIDAgPyAxMCA6IF9jLCBfZCA9IF9iLmlucHV0V2lkdGgsIGlucHV0V2lkdGggPSBfZCA9PT0gdm9pZCAwID8gMTI4IDogX2QsIF9lID0gX2IuaW5wdXRIZWlnaHQsIGlucHV0SGVpZ2h0ID0gX2UgPT09IHZvaWQgMCA/IDEyOCA6IF9lLCBfZiA9IF9iLmlvdVRocmVzaG9sZCwgaW91VGhyZXNob2xkID0gX2YgPT09IHZvaWQgMCA/IDAuMyA6IF9mLCBfZyA9IF9iLnNjb3JlVGhyZXNob2xkLCBzY29yZVRocmVzaG9sZCA9IF9nID09PSB2b2lkIDAgPyAwLjc1IDogX2csIG1vZGVsVXJsID0gX2IubW9kZWxVcmw7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmxhemVmYWNlLCBtb2RlbDtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfaCkge1xuICAgICAgICAgICAgc3dpdGNoIChfaC5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobW9kZWxVcmwgIT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0ZmNvbnYubG9hZEdyYXBoTW9kZWwobW9kZWxVcmwpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGJsYXplZmFjZSA9IF9oLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0ZmNvbnYubG9hZEdyYXBoTW9kZWwoQkxBWkVGQUNFX01PREVMX1VSTCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVRGSHViOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBibGF6ZWZhY2UgPSBfaC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9oLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsID0gbmV3IEJsYXplRmFjZU1vZGVsKGJsYXplZmFjZSwgaW5wdXRXaWR0aCwgaW5wdXRIZWlnaHQsIG1heEZhY2VzLCBpb3VUaHJlc2hvbGQsIHNjb3JlVGhyZXNob2xkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG1vZGVsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IEJsYXplRmFjZU1vZGVsLCBsb2FkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibGF6ZWZhY2UuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tensorflow-models/blazeface/dist/blazeface.esm.js\n");

/***/ })

};
;